provavelmente deverá ser feita uma mudança na estratégia de compactação (a escrita no começo do arquivo da árvore requer muita memória, podendo comprometer a taxa de compactação para arquivos grandes) (!!!falta fazer isso!!!)
alguns fors dos arquivos cliente.c, compactacao.c e descompactacao.c apresentavam uma condição de parada indevida (c!=eof em vez de !feof(fpin))
todos os fgetcs devem ser armazenados em variaveis do tipo int

pensamentos:
percebi que não há necessidade de escrever 0's e 1's no inicio do arquivo compactado para indicar nos nao folhas e nos folhas.

Isso porque caso os códigos das letras presentes na árvore de Huffman sejam escritos em ordem crescente no arquivo compactado
(assim como é feito para a construção inicial da árvore de Huffman), será possível reutilizar o algoritmo de Huffman para
reconstruir a árvore, mesmo que não haja informação de nós não raízes e raízes.
Suspeito que essa seja uma das razões que justificam a baixa taxa de compactação do meu trabalho em comparação a de outros.

Cabe agora analisar se esses bits adicionais que coloco inicialmente na mensagem justificam por completo a baixa taxa de compactação do programa,
e para isso seriam necessárias novas funções de código/revisão de funções preexistentes.
- Uma Função que diz quantos nós folhas e quantos nao folhas existem na árvore ajudaria
- Caso o problema na compactação seja realmente esse, seria necessário rever os métodos de compactação e descompactação
- Deveria ser criado uma nova lista, sendo essa para caracteres/strings (para então reconstruir a árvore de Huffman utilizando o algoritmo existente)
    - Ou então criar um método de huffman alternativo que funcionasse sem a necessidade de criar toda uma nova lista (que iria requerer um arquivo separado e etc)

O problema de fato está no algoritmo de huffman feito por mim ; ele produziu uma árvore cuja estrutura não favoreceu a construção de códigos pequenos para alguns caracteres mais repetitivos (a exemplo o ASCII 128). É preciso refazer essa função.

!!!!! O problema reside na processo de readição dos nós durante o algoritmo de huffman. Estou sempre readicionando ao final da lista, quando na verdade devo adicionar num índice determinado que mantenha a lista ordenada. !!!!!

foi necessário construir uma nova função de adição (ordenada), que por sua vez demandou uma série de funções interface e implementações em outros arquivos.

investigar o porque de nao conseguir descompactar o arquivo compactado de um arquivo .png

estou achando que o problema se encontra no arquivo descompactador.c na funcao traduzir mensagem, com o stopcode: essa variavel nao faz sentido, pois o arquivo png apresenta mais de 500 '\0' durante seu curso. Assim o programa para abruptamente de descompactar o arquivo ao se deparar com o primeiro '\0' e setar o stopcode como 1. Alias o stopcode em si nao faz sentido: era um método pensado para indicar que o arquivo terminou, no entanto funcoes como fread e scanf e feof são mais seguros para se identificar isso. Com isso em mente, no arquivo compactador.c na funcao de exportar_texto_bm, eu adiciono um caracter de terminação final no arquivo .comp, apenas para depois não le-lo/inclui-lo na descompactação por conta do stopcode; qual o sentido entao do stopcode e também de colocar um caracter de terminação no arquivo? nenhum.

agora preciso corrigir agora alguns pontos do relatório
	ALGUMAS FUNCOES DO ARQUIVO CLIENTE.C MUDARAM
